---
title: "Visium analysis placenta project"
author: "Ali Kerim Secener"
date: "8/13/2021"
output: html_document
---

```{r setup, include=FALSE}
knitr::opts_chunk$set(echo = TRUE, eval = F)
```

## Seurat processing
We load in the 10X output folders and process with Seurat.


```{r Seurat}
placenta <- Load10X_Spatial(filename = "filtered_feature_bc_matrix.h5", data.dir = "~/Documents/rproject/placenta/visium/B/outs/")

placenta <- SCTransform(placenta, assay = "Spatial", verbose = F)

placenta <- RunPCA(placenta, assay = "SCT", verbose = FALSE)
placenta <- FindNeighbors(placenta, reduction = "pca", dims = 1:30)
placenta <- FindClusters(placenta, verbose = FALSE)
placenta <- RunUMAP(placenta, reduction = "pca", dims = 1:30)


### compute spatially variable genes

placenta <- FindSpatiallyVariableFeatures(placenta, assay = "SCT", features = VariableFeatures(placenta)[1:1000],
    selection.method = "markvariogram")

saveRDS(placenta, "~/Documents/rproject/placenta/visium/B/placenta_visium_object.rds")
```

## Spotlight

```{r Spotlight}

library(SPOTlight)
### Load seurat marker table (FindAllMarkers) from single-nuclei dataset
LR <- read.csv("~/Downloads/Signatures_LogisticRegression_1503_covars.csv", row.names = "X")

### subset genes that you want to keep in the marker table
spot_genes <- read.csv("~/Downloads/Spotlight_Genes.csv", sep = ";")
spot_genes$clus_gene <- paste0(spot_genes$cluster, "_", spot_genes$gene)
gene_list <- spot_genes$clus_gene
gene_list <- unique(gene_list)

### filter marker table based on gene_list
LR_villi_unfiltered <- filter(LR, startsWith(x = cluster, prefix = "v"))
LR_villi_unfiltered$clus_gene <- paste0(LR_villi_unfiltered$cluster, "_", LR_villi_unfiltered$gene)
LR_villi_unfiltered$clus_gene[duplicated(LR_villi_unfiltered$clus_gene)] ## no duplicates here

LR_villi_filtered <- LR_villi_unfiltered %>% filter(LR_villi_unfiltered$clus_gene %in% gene_list)

spatial_object = placenta


### Run Spotlight
spotlight_ls <- spotlight_deconvolution(
  se_sc = villi, ##input your single cell/nuclei object from seurat
  counts_spatial = spatial_object@assays$Spatial@counts,
  clust_vr = "celltypes_semifinal_v2", # Variable in sc_seu containing the cell-type annotation
  cluster_markers = LR_villi_filtered, # Dataframe with the marker genes
  cl_n = 100, # number of cells per cell type to use
  hvg = 3000, # Number of HVG to use
  ntop = NULL, # How many of the marker genes to use (by default all)
  transf = "uv", # Perform unit-variance scaling per cell and spot prior to factorzation and NLS
  method = "nsNMF", # Factorization method
  min_cont = 0.01 # Remove those cells contributing to a spot below a certain threshold 
)

saveRDS(spotlight_ls, "~/Documents/rproject/placenta/visium/B/spotlight_ls_placenta.rds")


nmf_mod <- spotlight_ls[[1]]
decon_mtrx <- spotlight_ls[[2]]

h <- NMF::coef(nmf_mod[[1]])
rownames(h) <- paste("Topic", 1:nrow(h), sep = "_")
topic_profile_plts <- SPOTlight::dot_plot_profiles_fun(
  h = h,
  train_cell_clust = nmf_mod[[2]])

topic_per_gene <- nmf_mod[[1]]@fit@W
colnames(topic_per_gene) <- paste("Topic", 1:ncol(topic_per_gene), sep = "_")


topic_profile_plts[[2]]$data$`Cell type` <- factor(topic_profile_plts[[2]]$data$`Cell type`, levels = c("vBcell","vDC","vEB","vEVT","vFB","vHBC","vMC","vSCT","vSCTjuv","vTcell","vTSC","vVCT","vVEC"))

p <- topic_profile_plts[[2]] + ggplot2::theme(
  axis.text.x = ggplot2::element_text(angle = 90), 
  axis.text = ggplot2::element_text(size = 12))
p ## visualize the topic profiles for your cell type annotations

p <- topic_profile_plts[[1]] + theme(axis.text.x = element_text(angle = 90), 
                                axis.text = element_text(size = 12))




decon_mtrx_sub <- decon_mtrx[, colnames(decon_mtrx) != "res_ss"]
decon_mtrx_sub[decon_mtrx_sub < 0.08] <- 0
decon_mtrx <- cbind(decon_mtrx_sub, "res_ss" = decon_mtrx[, "res_ss"])
rownames(decon_mtrx) <- colnames(spatial_object)

decon_df <- decon_mtrx %>%
  data.frame() %>%
  tibble::rownames_to_column("barcodes")

spatial_object@meta.data <- spatial_object@meta.data %>%
  tibble::rownames_to_column("barcodes") %>%
  dplyr::left_join(decon_df, by = "barcodes") %>%
  tibble::column_to_rownames("barcodes")



cell_types_all <- colnames(decon_mtrx)[which(colnames(decon_mtrx) != "res_ss")]
colors_new <- c("#500352","#eaffcf","#ff873d","#DEC1FF","#7eafd6","#E60000","#b113d1","#ad3d00","#c9ffff",
                "#81a158","#00B3B3")
cell.types <- c("vTSC","vVEC","vDC","vFB","vEB","vHBC","vEVT","vMC","vSCT","vTcell","vVCT")
col_df <- data.frame(cell_type = cell.types, assigned_col = colors_new)
col_df <- data.frame(cell_type = cell.types, assigned_col = cols)

png("~/Documents/rproject/placenta/visium_figure/sectionB_spotlight.png", width = 2000, height = 2000, res = 600)


##plot the entire cell types
spatial_scatterpie(se_obj = spatial_object, 
                   cell_types_all = cell_types_all,
                   img_path = "~/Documents/rproject/placenta/visium/B/spatial/tissue_lowres_image.png", pie_scale = 0.4, scatterpie_alpha = 1) +
  scale_fill_manual(
    values = col_df[col_df$cell_type %in% cell_types_all, "assigned_col"],
    breaks = cell.types)

dev.off()



##plot the desired cell type(s)
spatial_scatterpie(se_obj = spatial_object,
                              cell_types_all = cell_types_all,
                              img_path = "../../placenta/visium/B/spatial/tissue_lowres_image.png",
                              cell_types_interest = "vSCTjuv",
                              pie_scale = 0.4) + 
  scale_fill_manual(
    values = col_df[col_df$cell_type %in% cell_types_all, "assigned_col"],
    breaks = cell.types)



###interaction graph
graph_ntw <- SPOTlight::get_spatial_interaction_graph(decon_mtrx = decon_mtrx[, cell_types_all])


deg <- degree(graph_ntw, mode="all")

# Get color palette for difusion
edge_importance <- E(graph_ntw)$importance

# Select a continuous palette
qual_col_pals <- brewer.pal.info[brewer.pal.info$category == 'seq',]

# Create a color palette
getPalette <- colorRampPalette(brewer.pal(9, "YlOrRd"))

# Get how many values we need
grad_edge <- seq(0, max(edge_importance), 0.1)

# Generate extended gradient palette dataframe
graph_col_df <- data.frame(value = as.character(grad_edge),
                           color = getPalette(length(grad_edge)),
                           stringsAsFactors = FALSE)
# Assign color to each edge
color_edge <- data.frame(value = as.character(round(edge_importance, 1)), stringsAsFactors = FALSE) %>%
  dplyr::left_join(graph_col_df, by = "value") %>%
  dplyr::pull(color)

# Open a pdf file
plot(graph_ntw,
     # Size of the edge
     edge.width = edge_importance,
     edge.color = color_edge,
     # Size of the buble
     vertex.size = deg,
     vertex.color = "#cde394",
     vertex.frame.color = "white",
     vertex.label.color = "black",
     vertex.label.family = "Arial", # Font family of the label (e.g.“Times”, “Helvetica”)
     layout = layout.circle)



decon_mtrx_sub <- decon_mtrx[, cell_types_all]
decon_mtrx_sub <- decon_mtrx_sub[, colSums(decon_mtrx_sub) > 0]

# Compute correlation
decon_cor <- cor(decon_mtrx_sub, method = "pearson")

# Compute correlation P-value
p.mat <- corrplot::cor.mtest(mat = decon_mtrx_sub, conf.level = 0.95)

# Visualize correlation plot
ggcorrplot::ggcorrplot(
  corr = decon_cor,
  p.mat = p.mat[[1]],
  hc.order = TRUE,
  type = "full",
  insig = "blank",
  lab = TRUE,
  outline.col = "lightgrey",
  method = "square",
  # colors = c("#4477AA", "white", "#BB4444"))
  colors = c("#6D9EC1", "white", "#E46726"),
  title = "Predicted cell-cell proportion correlation",
  legend.title = "Correlation\n(Pearson)") +
  ggplot2::theme(
    plot.title = ggplot2::element_text(size = 22, hjust = 0.5, face = "bold"),
    legend.text = ggplot2::element_text(size = 12),
    legend.title = ggplot2::element_text(size = 15),
    axis.text.x = ggplot2::element_text(angle = 90),
    axis.text = ggplot2::element_text(size = 18, vjust = 0.5))


```



